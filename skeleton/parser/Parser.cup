package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MULT, MINUS, LPAREN, RPAREN, RETURN, SEMI_COLON, RIGHT_CURL, LEFT_CURL, INT, PRINT, IF, ELSE,LESS,EQUALS, GREATER, AND, OR, NOT;
terminal Long    INTCONST;
terminal String IDENT;
terminal  UMINUS;
non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Stmt            stmt;
non terminal StmtList        stmt_list;
non terminal Condition       cond;
non terminal Block           b_list;
non terminal Block           body;
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left EQUALS;
precedence left LESS, GREATER;
precedence left PLUS, MINUS;
precedence left MULT;
precedence left UMINUS;

start with program;

program ::= INT IDENT LPAREN INT IDENT RPAREN LEFT_CURL stmt_list:slist RIGHT_CURL
            {: RESULT = new Program(slist, loc(slistleft, slistright)); :}
         ;

stmt_list::= stmt:s stmt_list:slist
{: RESULT = new StmtList(s,slist,loc(sleft,sright)); :}
| ""
{: RESULT = new StmtList("", loc(100,100)); :}
  ;

stmt ::=
    PRINT expr:e SEMI_COLON
      {: RESULT = new Stmt(e, "p", null, loc(eleft, eright)); :}
  | RETURN expr:e SEMI_COLON
      {: RESULT = new Stmt(e, "r", null, loc(eleft, eright)); :}
  | IF LPAREN cond:c RPAREN body:b
      {: RESULT = new IfStmt(b, c, loc(bleft, bright)); :}
  | IF LPAREN cond:c RPAREN body:b ELSE body: b2
    {: RESULT = new IfElseStmt(b, c, b2, loc(bleft, bright)); :}
  ;

body ::=stmt:s
      {: RESULT = new Block(s); :}
  |  LEFT_CURL b_list:b RIGHT_CURL
      {: RESULT = b; :}
  ;

b_list ::= ""
      {: RESULT = new Block(""); :}
  | stmt:s b_list:bl
      {: RESULT = new Block(s, bl); :}
  ;

  cond ::= expr: e1 LESS EQUALS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.LESS_EQUALS,loc(e2left,e2right)); :}
  |expr: e1 LESS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.LESS,loc(e2left,e2right)); :}
  | expr: e1 GREATER EQUALS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.GREATER_EQUALS,loc(e2left,e2right)); :}
  |expr: e1 GREATER expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.GREATER,loc(e2left,e2right)); :}
  |expr: e1 EQUALS EQUALS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.ABS_EQUALS,loc(e2left,e2right)); :}
  |expr: e1 NOT EQUALS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.NOT_EQUALS,loc(e2left,e2right)); :}
  |cond: c1 AND AND cond: c2
  {:RESULT = new Condition(null,null,c1,c2,Condition.AND,loc(c2left,c2right)); :}
  |cond: c1 OR OR cond: c2
  {:RESULT = new Condition(null,null,c1,c2,Condition.OR,loc(c2left,c2right)); :}
  | NOT cond:c1
  {:RESULT = new Condition(null,null,c1,null,Condition.NOT_COND,loc(c1left,c1right)); :}
  | RPAREN cond:c1 LPAREN
  {:RESULT = new Condition(null,null,c1,null,Condition.JUST_COND,loc(c1left,c1right)); :}
  ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      | MINUS expr:e
      {: RESULT = new UnaryMinus(e, loc(eleft, eright)); :}
      %prec UMINUS
       | binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
               | expr:e1 MULT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULT, e2, loc(e1left, e1right)); :}
            ;
