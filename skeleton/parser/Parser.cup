package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MULT, MINUS, LPAREN, RPAREN, RETURN, SEMI_COLON, RIGHT_CURL, LEFT_CURL, INT, PRINT, IF, ELSE,LESS,EQUALS;
terminal Long    INTCONST;
terminal String IDENT;
terminal  UMINUS;
non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Stmt            stmt;
non terminal StmtList        stmt_list;
non terminal Condition       cond;
non terminal Block           b_list;
non terminal Block           body;
precedence left PLUS, MINUS;
precedence left MULT;
precedence left UMINUS;

start with program;

program ::= INT IDENT LPAREN INT IDENT RPAREN LEFT_CURL stmt_list:slist RIGHT_CURL
            {: RESULT = new Program(slist, loc(slistleft, slistright)); :}
         ;

stmt_list::= stmt:s stmt_list:slist
{: RESULT = new StmtList(s,slist,loc(sleft,sright)); :}
| ""
{: RESULT = new StmtList("", loc(100,100)); :}
  ;

stmt ::=
    PRINT expr:e SEMI_COLON
      {: RESULT = new Stmt(e, "p", null, loc(eleft, eright)); :}
  | RETURN expr:e SEMI_COLON
      {: RESULT = new Stmt(e, "r", null, loc(eleft, eright)); :}
  | IF LPAREN cond:c RPAREN body:b
      {: RESULT = new IfStmt(b, c, loc(bleft, bright)); :}
  ;

body ::=stmt:s
      {: RESULT = new Block(s); :}
  |  LEFT_CURL b_list:b RIGHT_CURL
      {: RESULT = b; :}
  ;

b_list ::= ""
      {: RESULT = new Block(""); :}
  | stmt:s b_list:bl
      {: RESULT = new Block(s, bl); :}
  ;

  cond ::= expr: e1 LESS EQUALS expr: e2
  {:RESULT = new Condition(e1,e2,null,null,Condition.LESS_EQUALS,loc(e2left,e2right)); :}
  ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      | MINUS expr:e
      {: RESULT = new UnaryMinus(e, loc(eleft, eright)); :}
      %prec UMINUS
       | binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
               | expr:e1 MULT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULT, e2, loc(e1left, e1right)); :}
            ;
