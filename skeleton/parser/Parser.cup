package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MULT, MINUS, LPAREN, RPAREN, RETURN, SEMI_COLON, RIGHT_CURL, LEFT_CURL, INT, PRINT, IF, ELSE,LT, GT, 
NOT, EQ, LE, GE, AND, OR, NE,ASSIGN
terminal Long    INTCONST;
terminal String IDENT;
terminal  UMINUS;
non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Stmt            stmt;
non terminal StmtList        stmt_list;
non terminal Condition       cond;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left GE,LE,LT,EQ,NE;
precedence left PLUS, MINUS;
precedence left MULT;
precedence left UMINUS;

precedence left ELSE;

start with program;

program ::= INT IDENT LPAREN INT IDENT: param RPAREN LEFT_CURL stmt_list:slist RIGHT_CURL
            {: RESULT = new Program(slist, param, loc(slistleft, slistright)); :}
         ;

stmt_list::= stmt:s stmt_list:slist
{: RESULT = new StmtList(s,slist,loc(sleft,sright)); :}
| /*Empty String */
{: RESULT =null; :}
  ;

stmt ::= INT IDENT: varName ASSIGN expr: e SEMI_COLON
{: RESULT= new DeclStmt(varName, e, loc(varNameleft,varNameright)); :}
| IF LPAREN cond: c RPAREN stmt:s
{: RESULT= new IfStmt(c,s,null,loc(condleft,condright)); :}
| IF LPAREN cond: c RPAREN stmt:s1 ELSE stmt: s2
{: RESULT= new IfStmt(c,s1,s2,loc(condleft,condright)); :}
| PRINT expr:e SEMI_COLON
{: RESULT = new PrintStmt(e,loc(eleft,eright)); :}
| RETURN expr: e SEMI_COLON
{:RESULT = new ReturnStmt(e,loc(eleft,eright)); :}
| LEFT_CURL StmtList: sl RIGHT_CURL
{: RESULT = sl; :}
;

expr ::=
    INTCONST:c
      {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
  | MINUS expr:e
      {: RESULT = new UnaryMinus(e, loc(eleft, eright)); :}
      %prec UMINUS
  | binaryExpr:e
      {: RESULT = e; :}
  | LPAREN expr:e RPAREN
      {: RESULT = e; :}
  | IDENT: varName
    {: RESULT = new IdentExpr(varName, loc(varNameleft, varNameright)); :}
  ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
               | expr:e1 MULT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULT, e2, loc(e1left, e1right)); :}
            ;

cond::= expr: e1 LE expr:e2
{: RESULT = new CompCond(e1, CompCond.LE, e2, loc(e1left,e1right)); :}
|e1 GE expr:e2
{: RESULT = new CompCond(e1, CompCond.GE, e2, loc(e1left,e1right)); :}
|e1 LT expr:e2
{: RESULT = new CompCond(e1, CompCond.LT, e2, loc(e1left,e1right)); :}
|e1 GT expr:e2
{: RESULT = new CompCond(e1, CompCond.GT, e2, loc(e1left,e1right)); :}
|e1 EQ expr:e2
{: RESULT = new CompCond(e1, CompCond.EQ, e2, loc(e1left,e1right)); :}
|e1 NE expr:e2
{: RESULT = new CompCond(e1, CompCond.NE, e2, loc(e1left,e1right)); :}
| cond: e1 AND cond:e2
{:RESULT= new LogicalCond(e1,LogicalCond.AND, e2, loc(e1left,e1right)); :}
| cond: e1 OR cond:e2
{:RESULT= new LogicalCond(e1,LogicalCond.OR, e2, loc(e1left,e1right)); :}
| NOT cond: e
{:RESULT= new LogicalCond(e,LogicalCond.NOT, null, loc(eleft,eright)); :}
| LPAREN cond:c RPAREN
{: RESULT = c; :}
;